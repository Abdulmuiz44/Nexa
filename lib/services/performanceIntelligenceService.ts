import { createClient } from '@supabase/supabase-js';
import OpenAI from 'openai';
import { PerformanceInsight, ContentPerformanceMetrics, PerformanceDashboardData } from '@/types/features';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

let supabase: any = null;
if (supabaseUrl && supabaseKey) {
  supabase = createClient(supabaseUrl, supabaseKey);
} else {
  console.warn('Supabase environment variables not set - PerformanceIntelligenceService will not function');
  supabase = new Proxy({}, {
    get(_target, prop) {
      return () => {
        throw new Error('Supabase not configured - missing environment variables');
      };
    },
  });
}

let openai: any = null;
if (process.env.OPENAI_API_KEY) {
  openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
} else {
  console.warn('OpenAI API key not set - PerformanceIntelligenceService AI features will not function');
  openai = new Proxy({}, {
    get(_target, prop) {
      return () => {
        throw new Error('OpenAI not configured - missing API key');
      };
    },
  });
}

export class PerformanceIntelligenceService {
  /**
   * Generate comprehensive performance insights for a user
   */
  static async generateInsights(userId: string, days: number = 30): Promise<PerformanceInsight[]> {
    if (!supabase) {
      throw new Error('Supabase not configured');
    }

    const insights: PerformanceInsight[] = [];

    // Get best posting times
    const bestTimeInsight = await this.analyzeBestPostingTimes(userId, days);
    if (bestTimeInsight) insights.push(bestTimeInsight);

    // Get best performing content formats
    const bestFormatInsight = await this.analyzeBestContentFormat(userId, days);
    if (bestFormatInsight) insights.push(bestFormatInsight);

    // Get trending topics
    const trendingInsight = await this.analyzeTrendingTopics(userId, days);
    if (trendingInsight) insights.push(trendingInsight);

    return insights;
  }

  /**
   * Analyze best posting times based on engagement
   */
  private static async analyzeBestPostingTimes(userId: string, days: number): Promise<PerformanceInsight | null> {
    if (!supabase) {
      return null;
    }

    const { data: posts } = await supabase
      .from('posts')
      .select(`
        *,
        analytics (engagements, impressions, engagement_rate)
      `)
      .eq('user_id', userId)
      .eq('status', 'published')
      .gte('published_at', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString());

    if (!posts || posts.length === 0) return null;

    // Group by hour
    const hourlyData: Record<number, { total: number; avgEngagement: number }> = {};
    
    posts.forEach((post: any) => {
      if (post.published_at && post.analytics?.[0]) {
        const hour = new Date(post.published_at).getHours();
        if (!hourlyData[hour]) {
          hourlyData[hour] = { total: 0, avgEngagement: 0 };
        }
        hourlyData[hour].total++;
        hourlyData[hour].avgEngagement += post.analytics[0].engagement_rate || 0;
      }
    });

    // Calculate averages
    Object.keys(hourlyData).forEach(hour => {
      hourlyData[Number(hour)].avgEngagement /= hourlyData[Number(hour)].total;
    });

    // Find best hours
    const sortedHours = Object.entries(hourlyData)
      .sort(([, a], [, b]) => b.avgEngagement - a.avgEngagement)
      .slice(0, 3);

    const bestHours = sortedHours.map(([hour]) => Number(hour));

    return {
      id: '', // Will be generated by DB
      user_id: userId,
      insight_type: 'best_time',
      title: 'Optimal Posting Times',
      description: `Your posts perform best at ${bestHours.map(h => `${h}:00`).join(', ')}. Engagement rates are ${Math.round(sortedHours[0][1].avgEngagement * 100)}% higher during these times.`,
      data: { bestHours, hourlyData },
      confidence_score: sortedHours[0][1].total >= 5 ? 0.85 : 0.65,
      action_recommendation: `Schedule your important posts at ${bestHours[0]}:00 for maximum impact.`,
      created_at: new Date().toISOString()
    };
  }

  /**
   * Analyze best performing content formats
   */
  private static async analyzeBestContentFormat(userId: string, days: number): Promise<PerformanceInsight | null> {
    if (!supabase) {
      return null;
    }

    const { data: posts } = await supabase
      .from('posts')
      .select(`*, analytics (engagement_rate)`)
      .eq('user_id', userId)
      .eq('status', 'published')
      .gte('published_at', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString());

    if (!posts || posts.length === 0) return null;

    const formatData: Record<string, { count: number; totalEngagement: number }> = {};

    posts.forEach((post: any) => {
      const format = this.detectContentFormat(post.content);
      if (!formatData[format]) {
        formatData[format] = { count: 0, totalEngagement: 0 };
      }
      formatData[format].count++;
      formatData[format].totalEngagement += post.analytics?.[0]?.engagement_rate || 0;
    });

    const avgByFormat = Object.entries(formatData).map(([format, data]) => ({
      format,
      avgEngagement: data.totalEngagement / data.count,
      count: data.count
    })).sort((a, b) => b.avgEngagement - a.avgEngagement);

    const bestFormat = avgByFormat[0];

    return {
      id: '',
      user_id: userId,
      insight_type: 'best_format',
      title: 'Top Performing Content Format',
      description: `Your ${bestFormat.format} posts get ${Math.round(bestFormat.avgEngagement * 100)}% engagement rate on average.`,
      data: { formatPerformance: avgByFormat },
      confidence_score: bestFormat.count >= 5 ? 0.80 : 0.60,
      action_recommendation: `Create more ${bestFormat.format} content to maximize engagement.`,
      created_at: new Date().toISOString()
    };
  }

  /**
   * Detect content format based on structure
   */
  private static detectContentFormat(content: string): string {
    if (content.includes('?')) return 'question';
    if (content.match(/\d+[%$]/)) return 'statistic';
    if (content.toLowerCase().includes('how to')) return 'how-to';
    if (content.toLowerCase().includes('tip:')) return 'tip';
    if (content.split('\n').length > 3) return 'thread';
    return 'general';
  }

  /**
   * Analyze trending topics from successful posts
   */
  private static async analyzeTrendingTopics(userId: string, days: number): Promise<PerformanceInsight | null> {
    if (!supabase) {
      return null;
    }

    const { data: posts } = await supabase
      .from('posts')
      .select(`content, analytics (engagement_rate)`)
      .eq('user_id', userId)
      .eq('status', 'published')
      .gte('published_at', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString());

    if (!posts || posts.length < 10) return null;

    // Extract keywords from high-performing posts
    const highPerformers = posts
      .filter((p: any) => p.analytics?.[0]?.engagement_rate > 0.05)
      .map((p: any) => p.content);

    const keywords = this.extractKeywords(highPerformers.join(' '));

    return {
      id: '',
      user_id: userId,
      insight_type: 'trending_topic',
      title: 'Trending Topics for Your Audience',
      description: `Your audience engages most with: ${keywords.slice(0, 3).join(', ')}`,
      data: { trendingKeywords: keywords },
      confidence_score: 0.75,
      action_recommendation: `Create more content around these topics to boost engagement.`,
      created_at: new Date().toISOString()
    };
  }

  /**
   * Simple keyword extraction
   */
  private static extractKeywords(text: string): string[] {
    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'be', 'has', 'have', 'had']);
    const words = text.toLowerCase().match(/\b\w{4,}\b/g) || [];
    const wordCount: Record<string, number> = {};

    words.forEach(word => {
      if (!stopWords.has(word)) {
        wordCount[word] = (wordCount[word] || 0) + 1;
      }
    });

    return Object.entries(wordCount)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([word]) => word);
  }

  /**
   * Calculate and store performance metrics
   */
  static async calculateMetrics(userId: string, platform: 'twitter' | 'reddit'): Promise<void> {
    if (!supabase) {
      return;
    }

    const periods = ['daily', 'weekly', 'monthly'] as const;

    for (const period of periods) {
      const { start, end } = this.getPeriodDates(period);

      const { data: posts } = await supabase
        .from('posts')
        .select(`*, analytics (*)`)
        .eq('user_id', userId)
        .eq('platform', platform)
        .eq('status', 'published')
        .gte('published_at', start.toISOString())
        .lte('published_at', end.toISOString());

      if (!posts || posts.length === 0) continue;

      const totalImpressions = posts.reduce((sum: number, p: any) => 
        sum + (p.analytics?.[0]?.impressions || 0), 0);
      const totalEngagements = posts.reduce((sum: number, p: any) => 
        sum + (p.analytics?.[0]?.engagements || 0), 0);
      const avgEngagementRate = posts.reduce((sum: number, p: any) => 
        sum + (p.analytics?.[0]?.engagement_rate || 0), 0) / posts.length;

      await supabase.from('content_performance_metrics').insert({
        user_id: userId,
        period,
        period_start: start.toISOString().split('T')[0],
        period_end: end.toISOString().split('T')[0],
        platform,
        total_posts: posts.length,
        total_impressions: totalImpressions,
        total_engagements: totalEngagements,
        avg_engagement_rate: avgEngagementRate,
        metrics: { calculated_at: new Date().toISOString() }
      });
    }
  }

  /**
   * Get period dates
   */
  private static getPeriodDates(period: 'daily' | 'weekly' | 'monthly'): { start: Date; end: Date } {
    const end = new Date();
    const start = new Date();

    switch (period) {
      case 'daily':
        start.setHours(0, 0, 0, 0);
        break;
      case 'weekly':
        start.setDate(start.getDate() - 7);
        break;
      case 'monthly':
        start.setMonth(start.getMonth() - 1);
        break;
    }

    return { start, end };
  }

  /**
   * Get dashboard data with all insights and metrics
   */
  static async getDashboardData(userId: string): Promise<PerformanceDashboardData> {
    if (!supabase) {
      throw new Error('Supabase not configured');
    }

    const [insights, metrics] = await Promise.all([
      this.generateInsights(userId),
      supabase
        .from('content_performance_metrics')
        .select('*')
        .eq('user_id', userId)
        .eq('period', 'weekly')
        .order('period_start', { ascending: false })
        .limit(4)
        .then(res => res.data || [])
    ]);

    // Get best posting times
    const bestPostingTimes = await this.getBestPostingTimesData(userId);

    // Get content type performance
    const contentTypePerformance = await this.getContentTypePerformance(userId);

    // Get trends data
    const trendsData = await this.getTrendsData(userId, 30);

    return {
      insights,
      weeklyMetrics: metrics as ContentPerformanceMetrics[],
      bestPostingTimes,
      contentTypePerformance,
      trendsData
    };
  }

  private static async getBestPostingTimesData(userId: string): Promise<{ hour: number; engagement_rate: number }[]> {
    if (!supabase) {
      return [];
    }

    const { data: posts } = await supabase
      .from('posts')
      .select(`published_at, analytics (engagement_rate)`)
      .eq('user_id', userId)
      .eq('status', 'published');

    if (!posts) return [];

    const hourlyData: Record<number, number[]> = {};
    posts.forEach((post: any) => {
      if (post.published_at && post.analytics?.[0]) {
        const hour = new Date(post.published_at).getHours();
        if (!hourlyData[hour]) hourlyData[hour] = [];
        hourlyData[hour].push(post.analytics[0].engagement_rate || 0);
      }
    });

    return Object.entries(hourlyData)
      .map(([hour, rates]) => ({
        hour: Number(hour),
        engagement_rate: rates.reduce((a, b) => a + b, 0) / rates.length
      }))
      .sort((a, b) => a.hour - b.hour);
  }

  private static async getContentTypePerformance(userId: string): Promise<{ type: string; avg_engagement: number; count: number }[]> {
    if (!supabase) {
      return [];
    }

    const { data: posts } = await supabase
      .from('posts')
      .select(`content, analytics (engagement_rate)`)
      .eq('user_id', userId)
      .eq('status', 'published');

    if (!posts) return [];

    const typeData: Record<string, { total: number; count: number }> = {};
    posts.forEach((post: any) => {
      const type = this.detectContentFormat(post.content);
      if (!typeData[type]) typeData[type] = { total: 0, count: 0 };
      typeData[type].total += post.analytics?.[0]?.engagement_rate || 0;
      typeData[type].count++;
    });

    return Object.entries(typeData)
      .map(([type, data]) => ({
        type,
        avg_engagement: data.total / data.count,
        count: data.count
      }))
      .sort((a, b) => b.avg_engagement - a.avg_engagement);
  }

  private static async getTrendsData(userId: string, days: number): Promise<{ date: string; impressions: number; engagements: number }[]> {
    if (!supabase) {
      return [];
    }

    const { data: posts } = await supabase
      .from('posts')
      .select(`published_at, analytics (impressions, engagements)`)
      .eq('user_id', userId)
      .eq('status', 'published')
      .gte('published_at', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString());

    if (!posts) return [];

    const dailyData: Record<string, { impressions: number; engagements: number }> = {};
    posts.forEach((post: any) => {
      if (post.published_at && post.analytics?.[0]) {
        const date = post.published_at.split('T')[0];
        if (!dailyData[date]) dailyData[date] = { impressions: 0, engagements: 0 };
        dailyData[date].impressions += post.analytics[0].impressions || 0;
        dailyData[date].engagements += post.analytics[0].engagements || 0;
      }
    });

    return Object.entries(dailyData)
      .map(([date, data]) => ({ date, ...data }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }
}
